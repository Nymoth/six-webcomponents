{"version":3,"file":"static/js/9281.c6ff57a8.chunk.js","mappings":"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","sources":["../../../libraries/ui-library/dist/esm/src/utils/support.ts","../../../libraries/ui-library/dist/esm/src/utils/modal.ts","../../../libraries/ui-library/dist/esm/src/utils/offset.ts","../../../libraries/ui-library/dist/esm/src/utils/scroll.ts","../../../libraries/ui-library/dist/esm/src/components/six-dialog/six-dialog.tsx","../../../libraries/ui-library/dist/esm/src/components/six-dialog/six-dialog.scss?tag=six-dialog&encapsulation=shadow","../../../libraries/ui-library/dist/esm/src/utils/slot.ts"],"sourcesContent":["//\n// Determines if the browser supports focus({ preventScroll })\n//\nexport const isPreventScrollSupported = () => {\n  let supported = false;\n\n  const element = document.createElement('div');\n  element.focus &&\n    element.focus({\n      get preventScroll() {\n        supported = true;\n        return false;\n      },\n    });\n\n  return supported;\n};\n","interface ModalOptions {\n  onFocusOut?: (event: Event) => void;\n}\n\nlet activeModals: HTMLElement[] = [];\n\nexport default class Modal {\n  element: HTMLElement;\n  options?: ModalOptions;\n\n  constructor(element: HTMLElement, options?: ModalOptions) {\n    this.element = element;\n    this.options = options;\n    this.handleFocusIn = this.handleFocusIn.bind(this);\n  }\n\n  activate() {\n    activeModals.push(this.element);\n    document.addEventListener('focusin', this.handleFocusIn);\n  }\n\n  deactivate() {\n    activeModals = activeModals.filter((modal) => modal !== this.element);\n    document.removeEventListener('focusin', this.handleFocusIn);\n  }\n\n  isActive() {\n    // The \"active\" modal is always the most recent one shown\n    return activeModals[activeModals.length - 1] === this.element;\n  }\n\n  handleFocusIn(event: Event) {\n    const target = event.target as HTMLElement;\n    const tagName = this.element.tagName.toLowerCase();\n\n    // If focus is lost while the modal is active, run the onFocusOut callback\n    if (this.isActive() && target.closest(tagName) !== this.element && typeof this.options?.onFocusOut === 'function') {\n      this.options?.onFocusOut(event);\n    }\n  }\n}\n","//\n// Returns an element's offset relative to its parent. Similar to element.offsetTop and element.offsetLeft, except the\n// parent doesn't have to be positioned relative or absolute.\n//\n// NOTE: This was created to work around what appears to be a bug in Chrome where a slotted element's offsetParent\n// seems to ignore elements inside the surrounding shadow DOM: https://bugs.chromium.org/p/chromium/issues/detail?id=920069\n//\nexport function getOffset(element: HTMLElement, parent: HTMLElement) {\n  return {\n    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),\n    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left),\n  };\n}\n","import { getOffset } from './offset';\n\nconst locks = new Set();\n\n//\n// Prevents body scrolling. Keeps track of which elements requested a lock so multiple levels of locking are possible\n// without premature unlocking.\n//\nexport function lockBodyScrolling(lockingEl: HTMLElement) {\n  locks.add(lockingEl);\n  document.body.classList.add('six-scroll-lock');\n}\n\n//\n// Unlocks body scrolling. Scrolling will only be unlocked once all elements that requested a lock call this method.\n//\nexport function unlockBodyScrolling(lockingEl: HTMLElement) {\n  locks.delete(lockingEl);\n\n  if (locks.size === 0) {\n    document.body.classList.remove('six-scroll-lock');\n  }\n}\n\n//\n// Scrolls an element into view of its container. If the element is already in view, nothing will happen.\n//\nexport function scrollIntoView(\n  element: HTMLElement,\n  container: HTMLElement,\n  direction: 'horizontal' | 'vertical' | 'both' = 'vertical',\n  behavior: 'smooth' | 'auto' = 'smooth'\n) {\n  const offset = getOffset(element, container);\n  const offsetTop = offset.top + container.scrollTop;\n  const offsetLeft = offset.left + container.scrollLeft;\n  const minX = container.scrollLeft;\n  const maxX = container.scrollLeft + container.offsetWidth;\n  const minY = container.scrollTop;\n  const maxY = container.scrollTop + container.offsetHeight;\n\n  if (direction === 'horizontal' || direction === 'both') {\n    if (offsetLeft < minX) {\n      container.scrollTo({ left: offsetLeft, behavior });\n    } else if (offsetLeft + element.clientWidth > maxX) {\n      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });\n    }\n  }\n\n  if (direction === 'vertical' || direction === 'both') {\n    if (offsetTop < minY) {\n      container.scrollTo({ top: offsetTop, behavior });\n    } else if (offsetTop + element.clientHeight > maxY) {\n      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });\n    }\n  }\n}\n","import { Component, Element, Event, EventEmitter, h, Method, Prop, State, Watch } from '@stencil/core';\nimport { lockBodyScrolling, unlockBodyScrolling } from '../../utils/scroll';\nimport { hasSlot } from '../../utils/slot';\nimport { isPreventScrollSupported } from '../../utils/support';\nimport Modal from '../../utils/modal';\nimport { EmptyPayload } from '../../utils/types';\n\nconst hasPreventScroll = isPreventScrollSupported();\n\nlet id = 0;\n\n/**\n * @since 1.0\n * @status stable\n *\n * Forked from https://github.com/shoelace-style/shoelace version v2.0.0-beta27.\n *\n * @slot - The dialog's content.\n * @slot label - The dialog's label. Alternatively, you can use the label prop.\n * @slot footer - The dialog's footer, usually one or more buttons representing various options.\n *\n * @part base - The component's base wrapper.\n * @part overlay - The overlay.\n * @part panel - The dialog panel (where the dialog and its content is rendered).\n * @part header - The dialog header.\n * @part title - The dialog title.\n * @part close-button - The close button.\n * @part body - The dialog body.\n * @part footer - The dialog footer.\n *\n */\n@Component({\n  tag: 'six-dialog',\n  styleUrl: 'six-dialog.scss',\n  shadow: true,\n})\nexport class SixDialog {\n  private componentId = `dialog-${++id}`;\n  private dialog?: HTMLElement;\n  private modal?: Modal;\n  private panel?: HTMLElement;\n  private willShow = false;\n  private willHide = false;\n\n  @Element() host!: HTMLSixDialogElement;\n\n  @State() hasFooter = false;\n  @State() isVisible = false;\n\n  /** Indicates whether the dialog is open. You can use this in lieu of the show/hide methods. */\n  @Prop({ mutable: true, reflect: true }) open = false;\n\n  /**\n   * The dialog's label as displayed in the header. You should always include a relevant label even when using\n   * `no-header`, as it is required for proper accessibility.\n   */\n  @Prop() label = '';\n\n  /**\n   * Set to true to disable the header. This will also remove the default close button, so please ensure you provide an\n   * easy, accessible way for users to dismiss the dialog.\n   */\n  @Prop() noHeader = false;\n\n  @Watch('open')\n  handleOpenChange() {\n    this.open ? this.show() : this.hide();\n  }\n\n  /** Emitted when the dialog opens. Calling `event.preventDefault()` will prevent it from being opened. */\n  @Event({ eventName: 'six-dialog-show' }) sixShow!: EventEmitter<EmptyPayload>;\n\n  /** Emitted after the dialog opens and all transitions are complete. */\n  @Event({ eventName: 'six-dialog-after-show' }) sixAfterShow!: EventEmitter<EmptyPayload>;\n\n  /** Emitted when the dialog closes. Calling `event.preventDefault()` will prevent it from being closed. */\n  @Event({ eventName: 'six-dialog-hide' }) sixHide!: EventEmitter<EmptyPayload>;\n\n  /** Emitted after the dialog closes and all transitions are complete. */\n  @Event({ eventName: 'six-dialog-after-hide' }) sixAfterHide!: EventEmitter<EmptyPayload>;\n\n  /**\n   * Emitted when the dialog opens and the panel gains focus. Calling `event.preventDefault()` will prevent focus and\n   * allow you to set it on a different element in the dialog, such as an input or button.\n   */\n  @Event({ eventName: 'six-dialog-initial-focus' }) sixInitialFocus!: EventEmitter<EmptyPayload>;\n\n  /** Emitted when the overlay is clicked. Calling `event.preventDefault()` will prevent the dialog from closing. */\n  @Event({ eventName: 'six-dialog-overlay-dismiss' }) sixOverlayDismiss!: EventEmitter<EmptyPayload>;\n\n  connectedCallback() {\n    this.modal = new Modal(this.host, {\n      onFocusOut: () => this.panel?.focus(),\n    });\n  }\n\n  componentWillLoad() {\n    this.handleSlotChange();\n\n    // Show on init if open\n    if (this.open) {\n      this.show();\n    }\n  }\n\n  disconnectedCallback() {\n    unlockBodyScrolling(this.host);\n  }\n\n  /** Shows the dialog */\n  @Method()\n  async show() {\n    if (this.willShow || this.modal == null || this.panel == null || this.dialog == null) {\n      return;\n    }\n    const panel = this.panel;\n\n    const sixShow = this.sixShow.emit();\n    if (sixShow.defaultPrevented) {\n      this.open = false;\n      return;\n    }\n\n    this.willShow = true;\n    this.isVisible = true;\n    this.open = true;\n    this.modal.activate();\n\n    lockBodyScrolling(this.host);\n\n    if (this.open) {\n      if (hasPreventScroll) {\n        // Wait for the next frame before setting initial focus so the dialog is technically visible\n        requestAnimationFrame(() => {\n          const sixInitialFocus = this.sixInitialFocus.emit();\n          if (!sixInitialFocus.defaultPrevented) {\n            panel.focus({ preventScroll: true });\n          }\n        });\n      } else {\n        // Once Safari supports { preventScroll: true } we can remove this nasty little hack, but until then we need to\n        // wait for the transition to complete before setting focus, otherwise the panel may render in a buggy way its\n        // out of view initially.\n        //\n        // Fiddle: https://jsfiddle.net/g6buoafq/1/\n        // Safari: https://bugs.webkit.org/show_bug.cgi?id=178583\n        //\n        this.dialog.addEventListener(\n          'transitionend',\n          () => {\n            const sixInitialFocus = this.sixInitialFocus.emit();\n            if (!sixInitialFocus.defaultPrevented) {\n              panel.focus();\n            }\n          },\n          { once: true }\n        );\n      }\n    }\n  }\n\n  /** Hides the dialog */\n  @Method()\n  async hide() {\n    if (this.willHide || this.modal == null) {\n      return;\n    }\n\n    const sixHide = this.sixHide.emit();\n    if (sixHide.defaultPrevented) {\n      this.open = true;\n      return;\n    }\n\n    this.willHide = true;\n    this.open = false;\n    this.modal.deactivate();\n\n    unlockBodyScrolling(this.host);\n  }\n\n  private handleCloseClick = () => {\n    this.hide();\n  };\n\n  private handleKeyDown = (event: KeyboardEvent) => {\n    if (event.key === 'Escape') {\n      this.hide();\n    }\n  };\n\n  private handleOverlayClick = () => {\n    const sixOverlayDismiss = this.sixOverlayDismiss.emit();\n\n    if (!sixOverlayDismiss.defaultPrevented) {\n      this.hide();\n    }\n  };\n\n  private handleSlotChange = () => {\n    this.hasFooter = hasSlot(this.host, 'footer');\n  };\n\n  private handleTransitionEnd = (event: TransitionEvent) => {\n    const target = event.target as HTMLElement;\n\n    // Ensure we only emit one event when the target element is no longer visible\n    if (event.propertyName === 'opacity' && target.classList.contains('dialog__panel')) {\n      this.isVisible = this.open;\n      this.willShow = false;\n      this.willHide = false;\n      this.open ? this.sixAfterShow.emit() : this.sixAfterHide.emit();\n    }\n  };\n\n  render() {\n    return (\n      <div\n        ref={(el) => (this.dialog = el)}\n        part=\"base\"\n        class={{\n          dialog: true,\n          'dialog--open': this.open,\n          'dialog--visible': this.isVisible,\n          'dialog--has-footer': this.hasFooter,\n        }}\n        onKeyDown={this.handleKeyDown}\n        onTransitionEnd={this.handleTransitionEnd}\n      >\n        <div part=\"overlay\" class=\"dialog__overlay\" onClick={this.handleOverlayClick} />\n\n        <div\n          ref={(el) => (this.panel = el)}\n          part=\"panel\"\n          class=\"dialog__panel\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-hidden={this.open ? 'false' : 'true'}\n          aria-label={this.noHeader ? this.label : null}\n          aria-labelledby={!this.noHeader ? `${this.componentId}-title` : null}\n          tabIndex={0}\n        >\n          {!this.noHeader && (\n            <header part=\"header\" class=\"dialog__header\">\n              <span part=\"title\" class=\"dialog__title\" id={`${this.componentId}-title`}>\n                <slot name=\"label\">\n                  {/* If there's no label, use an invisible character to prevent the heading from collapsing */}\n                  {this.label || String.fromCharCode(65279)}\n                </slot>\n              </span>\n              <six-icon-button\n                exportparts=\"base:close-button\"\n                class=\"dialog__close\"\n                name=\"close\"\n                onClick={this.handleCloseClick}\n              />\n            </header>\n          )}\n\n          <div part=\"body\" class=\"dialog__body\">\n            <slot />\n          </div>\n\n          <footer part=\"footer\" class=\"dialog__footer\">\n            <slot name=\"footer\" onSlotchange={this.handleSlotChange} />\n          </footer>\n        </div>\n      </div>\n    );\n  }\n}\n","@import 'src/global/component';\n@import 'src/global/mixins/hidden';\n\n/**\n * @prop --width: The preferred width of the dialog. Note that the dialog will shrink to accommodate smaller screens.\n */\n:host {\n  --width: 31rem;\n\n  display: contents;\n}\n\n.dialog {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: var(--six-z-index-dialog);\n  color: var(--six-color-web-rock-900);\n\n  &:not(.dialog--visible) {\n    @include hidden;\n  }\n}\n\n.dialog__panel {\n  display: flex;\n  flex-direction: column;\n  z-index: 2;\n  width: var(--width);\n  max-width: calc(100% - var(--six-spacing-xx-large));\n  max-height: calc(100% - var(--six-spacing-xx-large));\n  background-color: var(--six-panel-background-color);\n  border-radius: var(--six-border-radius-medium);\n  box-shadow: var(--six-shadow-x-large);\n  opacity: 0;\n  transform: scale(0.8);\n  transition: var(--six-transition-medium) opacity, var(--six-transition-medium) transform;\n\n  &:focus {\n    outline: none;\n  }\n}\n\n// Ensure there's enough vertical padding for phones that don't update vh when chrome appears (e.g. iPhone)\n@media screen and (max-width: 420px) {\n  .dialog__panel {\n    max-height: 80vh;\n  }\n}\n\n.dialog--open .dialog__panel {\n  display: flex;\n  opacity: 1;\n  transform: none;\n}\n\n.dialog__header {\n  flex: 0 0 auto;\n  display: flex;\n}\n\n.dialog__title {\n  flex: 1 1 auto;\n  font-size: var(--six-font-size-x-large);\n  font-weight: var(--six-font-weight-bold);\n  line-height: var(--six-line-height-dense);\n  padding: var(--six-spacing-large) var(--six-spacing-large) var(--six-spacing-small);\n}\n\n.dialog__close {\n  flex: 0 0 auto;\n  display: flex;\n  align-items: center;\n  font-size: var(--six-font-size-x-large);\n  padding: 0 var(--six-spacing-x-small);\n}\n\n.dialog__body {\n  flex: 1 1 auto;\n  padding: var(--six-spacing-small) var(--six-spacing-large) var(--six-spacing-large);\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n\n.dialog__footer {\n  flex: 0 0 auto;\n  text-align: right;\n  padding: var(--six-spacing-large);\n\n  ::slotted(six-button:not(:first-of-type)) {\n    margin-left: var(--six-spacing-xx-small);\n  }\n}\n\n.dialog:not(.dialog--has-footer) .dialog__footer {\n  display: none;\n}\n\n.dialog__overlay {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-color: var(--six-overlay-background-color);\n  opacity: 0;\n  transition: var(--six-transition-medium) opacity;\n}\n\n.dialog--open .dialog__overlay {\n  opacity: 0.8;\n}\n","//\n// Given a slot, this function iterates over all of its assigned text nodes and returns the concatenated text as a\n// string. This is useful because we can't use slot.textContent as an alternative.\n//\nexport function getTextContent(slot?: HTMLSlotElement): string {\n  const nodes = slot != null ? slot.assignedNodes({ flatten: true }) : [];\n  let text = '';\n\n  [...nodes].map((node) => {\n    if (node.nodeType === Node.TEXT_NODE) {\n      text += node.textContent;\n    }\n  });\n\n  return text;\n}\n\n//\n// Determines whether an element has a slot. If name is specified, the function will look for a corresponding named\n// slot, otherwise it will look for a \"default\" slot (e.g. a non-empty text node or an element with no slot attribute).\n//\nexport function hasSlot(el: HTMLElement, name?: string): boolean {\n  // Look for a named slot\n  if (name != null && name !== '') {\n    return el.querySelector(`[slot=\"${name}\"]`) !== null;\n  }\n\n  // Look for a default slot\n  return Array.from(el.childNodes).some((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent?.trim() !== '') {\n      return true;\n    }\n\n    if (node.nodeType === node.ELEMENT_NODE) {\n      const el = node as HTMLElement;\n      if (!el.hasAttribute('slot')) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n}\n\nexport const getSlotChildren = <T extends HTMLElement>(el: HTMLElement) =>\n  el.querySelector('slot')?.assignedElements({ flatten: true }) as T[];\n\nexport function getSlot(element: ParentNode | null | undefined, slotName: string): HTMLElement | null {\n  if (element == null) return null;\n  return element.querySelector(`[slot=\"${slotName}\"]`);\n}\n"],"names":["isPreventScrollSupported","supported","element","document","createElement","focus","preventScroll","activeModals","Modal","options","this","handleFocusIn","bind","push","addEventListener","filter","modal","removeEventListener","length","event","target","tagName","toLowerCase","isActive","closest","onFocusOut","getOffset","parent","top","Math","round","getBoundingClientRect","left","locks","Set","lockBodyScrolling","lockingEl","add","body","classList","unlockBodyScrolling","delete","size","remove","scrollIntoView","container","direction","behavior","offset","offsetTop","scrollTop","offsetLeft","scrollLeft","minX","maxX","offsetWidth","minY","maxY","offsetHeight","scrollTo","clientWidth","clientHeight","hasPreventScroll","id","SixDialog","componentId","willShow","willHide","handleCloseClick","hide","handleKeyDown","key","handleOverlayClick","sixOverlayDismiss","emit","defaultPrevented","handleSlotChange","hasFooter","hasSlot","host","handleTransitionEnd","propertyName","contains","isVisible","open","sixAfterShow","sixAfterHide","show","panel","dialog","sixShow","activate","requestAnimationFrame","sixInitialFocus","once","sixHide","deactivate","h","ref","el","part","class","onKeyDown","onTransitionEnd","onClick","role","noHeader","label","tabIndex","name","String","fromCharCode","exportparts","onSlotchange","getTextContent","slot","nodes","assignedNodes","flatten","text","map","node","nodeType","Node","TEXT_NODE","textContent","querySelector","Array","from","childNodes","some","trim","ELEMENT_NODE","hasAttribute","getSlotChildren","assignedElements","getSlot","slotName"],"sourceRoot":""}