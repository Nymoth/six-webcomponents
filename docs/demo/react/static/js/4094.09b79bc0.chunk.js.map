{"version":3,"file":"static/js/4094.09b79bc0.chunk.js","mappings":"gQAeaA,EAAmB,W,yDAsCtB,KAAAC,YAAc,SAACC,GACrB,OAAI,EAAKC,uBAELC,EAAAA,EAAAA,GAAAA,MAAAA,CAAKC,KAAMH,IACTE,EAAAA,EAAAA,GAAAA,OAAAA,CAAMF,KAAMA,MAMhBE,EAAAA,EAAAA,GAAAA,OAAAA,CACEF,KAAMA,EACNI,aAAc,W,MACND,EAA2B,QAApB,IAAKE,KAAKC,kBAAU,eAAEC,cAAa,qBAAgCP,EAAI,OACxE,MAARG,IACF,EAAKF,sBAAwBE,EAAKK,gBAAgBC,OAAS,E,oBAlDjD,E,UAGL,G,UAGA,G,WAGkB,G,WAGD,E,oDAKC,C,iDAEjC,WACEC,KAAKC,iBAAmBD,KAAKC,iBAAiBC,KAAKF,K,GACpD,+BAED,WACEA,KAAKC,kB,GACN,8BAEO,WACND,KAAKG,UAAWC,EAAAA,EAAAA,GAAQJ,KAAKL,K,GAC9B,wBAEO,W,MACN,OAAqE,OAAvC,QAAvB,EAAAK,KAAKL,KAAKU,qBAAa,eAAEC,QAAQ,0B,GACzC,oBAwBD,WACE,OACEd,EAAAA,EAAAA,GAAAA,cAAAA,CACEe,MAAO,CACL,0BAA0B,EAC1B,qCAAsCP,KAAKG,SAC3C,mCAAoCH,KAAKQ,cAE3CC,QAAQ,EACRC,KAAMV,KAAKU,KAAI,eACDV,KAAKW,YACnBC,WAAYZ,KAAKG,WAEjBX,EAAAA,EAAAA,GAAAA,MAAAA,CAAKC,KAAK,YACRD,EAAAA,EAAAA,GAAAA,MAAAA,CAAKe,MAAM,+BACRP,KAAKa,OAAQrB,EAAAA,EAAAA,GAAAA,WAAAA,CAAUe,MAAM,oCAAoCP,KAAKa,MACtEb,KAAKV,OAGTU,KAAKX,YAAY,iBAClBG,EAAAA,EAAAA,GAAAA,OAAAA,M,GAGL,2B,0BAnF6B,G,QCfD,qhB,mJCIfsB,EAAerB,GAC7B,IAAMsB,EAAgB,MAARtB,EAAeA,EAAKK,cAAc,CAAEkB,SAAS,IAAU,GACjEC,EAAO,GAQX,OANA,OAAIF,GAAOG,KAAI,SAACC,GACVA,EAAKC,WAAaC,KAAKC,YACzBL,GAAQE,EAAKI,Y,IAIVN,CACT,C,SAMgBb,EAAQoB,EAAiBlC,GAEvC,OAAY,MAARA,GAAyB,KAATA,EAC8B,OAAzCkC,EAAG3B,cAAc,UAAD,OAAWP,EAAI,OAIjCmC,MAAMC,KAAKF,EAAGG,YAAYC,MAAK,SAACT,G,MACrC,GAAIA,EAAKC,WAAaD,EAAKG,WAA0C,MAAb,QAAhB,EAAAH,EAAKI,mBAAW,eAAEM,QACxD,OAAO,EAGT,GAAIV,EAAKC,WAAaD,EAAKW,eACdX,EACHY,aAAa,QACnB,OAAO,EAIX,OAAO,C,GAEX,C,IAEaC,EAAkB,SAAwBR,GAAe,MACpE,OAAwB,QAAxB,EAAAA,EAAG3B,cAAc,eAAO,eAAEoC,iBAAiB,CAAEjB,SAAS,GAAc,E,SAEtDkB,EAAQC,EAAwCC,GAC9D,OAAe,MAAXD,EAAwB,KACrBA,EAAQtC,cAAc,UAAD,OAAWuC,EAAQ,MACjD,C","sources":["../../../libraries/ui-library/dist/esm/src/components/six-sidebar-item-group/six-sidebar-item-group.tsx","../../../libraries/ui-library/dist/esm/src/components/six-sidebar-item-group/six-sidebar-item-group.scss?tag=six-sidebar-item-group&encapsulation=shadow","../../../libraries/ui-library/dist/esm/src/utils/slot.ts"],"sourcesContent":["import { Component, Element, h, Prop, State } from '@stencil/core';\nimport { hasSlot } from '../../utils/slot';\n\n/**\n * @since 1.0\n * @status stable\n *\n * @slot - Used to define the nested sidebar [group] items.\n */\n\n@Component({\n  tag: 'six-sidebar-item-group',\n  styleUrl: 'six-sidebar-item-group.scss',\n  shadow: true,\n})\nexport class SixSidebarItemGroup {\n  @Element() readonly host!: HTMLSixSidebarItemGroupElement;\n\n  @State() hasItems = false;\n\n  /** Title of item group */\n  @Prop() name = '';\n\n  /** Icon of the group */\n  @Prop() icon = '';\n\n  /** A unique value to store in the sidebar item of the group label. This can be used as a way to identify sidebar items when selected. */\n  @Prop({ reflect: true }) value = '';\n\n  /** Indicates whether the sidebar is shown */\n  @Prop({ reflect: true }) open = false;\n\n  /** Custom summary icon name. */\n  @Prop() summaryIcon?: string;\n\n  @State() summaryIconHasContent = false;\n\n  connectedCallback() {\n    this.handleSlotChange = this.handleSlotChange.bind(this);\n  }\n\n  componentWillLoad() {\n    this.handleSlotChange();\n  }\n\n  private handleSlotChange() {\n    this.hasItems = hasSlot(this.host);\n  }\n\n  private isSubgroup() {\n    return this.host.parentElement?.closest('six-sidebar-item-group') != null;\n  }\n\n  private provideSlot = (name: string) => {\n    if (this.summaryIconHasContent) {\n      return (\n        <div slot={name}>\n          <slot name={name}></slot>\n        </div>\n      );\n    }\n\n    return (\n      <slot\n        name={name}\n        onSlotchange={() => {\n          const slot = this.host.shadowRoot?.querySelector<HTMLSlotElement>(`slot[name=\"${name}\"]`);\n          if (slot != null) {\n            this.summaryIconHasContent = slot.assignedNodes().length > 0;\n          }\n        }}\n      ></slot>\n    );\n  };\n\n  render() {\n    return (\n      <six-details\n        class={{\n          'six-sidebar-item-group': true,\n          'six-sidebar-item-group--childless': !this.hasItems,\n          'six-sidebar-item-group--subgroup': this.isSubgroup(),\n        }}\n        inline={true}\n        open={this.open}\n        summary-icon={this.summaryIcon}\n        hasContent={this.hasItems}\n      >\n        <div slot=\"summary\">\n          <div class=\"six-sidebar-details__header\">\n            {this.icon && <six-icon class=\"six-sidebar-details__header-icon\">{this.icon}</six-icon>}\n            {this.name}\n          </div>\n        </div>\n        {this.provideSlot('summary-icon')}\n        <slot />\n      </six-details>\n    );\n  }\n}\n","@import 'src/global/component';\n\n:host {\n  display: block;\n}\n\n.six-sidebar-item-group {\n  --horizontal-padding: var(--six-spacing-x-large);\n}\n\n.six-sidebar-item-group--childless::part(content) {\n  padding: 0 !important;\n}\n\n.six-sidebar-item-group--subgroup::part(header) {\n  background-color: transparent !important;\n}\n\n.six-sidebar-item-group__header-icon {\n  margin-left: 16px;\n  transform: translate(0px, -3px);\n}\n\n.six-sidebar-details__header {\n  display: flex;\n}\n\n.six-sidebar-details__header-icon {\n  margin-right: 1em;\n}\n","//\n// Given a slot, this function iterates over all of its assigned text nodes and returns the concatenated text as a\n// string. This is useful because we can't use slot.textContent as an alternative.\n//\nexport function getTextContent(slot?: HTMLSlotElement): string {\n  const nodes = slot != null ? slot.assignedNodes({ flatten: true }) : [];\n  let text = '';\n\n  [...nodes].map((node) => {\n    if (node.nodeType === Node.TEXT_NODE) {\n      text += node.textContent;\n    }\n  });\n\n  return text;\n}\n\n//\n// Determines whether an element has a slot. If name is specified, the function will look for a corresponding named\n// slot, otherwise it will look for a \"default\" slot (e.g. a non-empty text node or an element with no slot attribute).\n//\nexport function hasSlot(el: HTMLElement, name?: string): boolean {\n  // Look for a named slot\n  if (name != null && name !== '') {\n    return el.querySelector(`[slot=\"${name}\"]`) !== null;\n  }\n\n  // Look for a default slot\n  return Array.from(el.childNodes).some((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent?.trim() !== '') {\n      return true;\n    }\n\n    if (node.nodeType === node.ELEMENT_NODE) {\n      const el = node as HTMLElement;\n      if (!el.hasAttribute('slot')) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n}\n\nexport const getSlotChildren = <T extends HTMLElement>(el: HTMLElement) =>\n  el.querySelector('slot')?.assignedElements({ flatten: true }) as T[];\n\nexport function getSlot(element: ParentNode | null | undefined, slotName: string): HTMLElement | null {\n  if (element == null) return null;\n  return element.querySelector(`[slot=\"${slotName}\"]`);\n}\n"],"names":["SixSidebarItemGroup","provideSlot","name","summaryIconHasContent","h","slot","onSlotchange","host","shadowRoot","querySelector","assignedNodes","length","this","handleSlotChange","bind","hasItems","hasSlot","parentElement","closest","class","isSubgroup","inline","open","summaryIcon","hasContent","icon","getTextContent","nodes","flatten","text","map","node","nodeType","Node","TEXT_NODE","textContent","el","Array","from","childNodes","some","trim","ELEMENT_NODE","hasAttribute","getSlotChildren","assignedElements","getSlot","element","slotName"],"sourceRoot":""}