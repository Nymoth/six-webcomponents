{"version":3,"sources":["webpack:///./node_modules/@six/ui-library/dist/esm/modal-e5709f6b.js","webpack:///./node_modules/@six/ui-library/dist/esm/six-drawer.entry.js","webpack:///./node_modules/@six/ui-library/dist/esm/slot-5253e199.js","webpack:///./node_modules/@six/ui-library/dist/esm/scroll-99b214c2.js"],"names":["isPreventScrollSupported","supported","element","document","createElement","focus","activeModals","Modal","options","this","handleFocusIn","bind","push","addEventListener","filter","modal","removeEventListener","length","event","target","tagName","toLowerCase","isActive","closest","onFocusOut","sixDrawerCss","hasPreventScroll","id","SixDrawer","hostRef","sixShow","sixAfterShow","sixHide","sixAfterHide","sixInitialFocus","sixOverlayDismiss","componentId","willShow","willHide","hasFooter","isVisible","open","label","placement","contained","noHeader","show","hide","handleCloseClick","handleTransitionEnd","handleKeyDown","handleOverlayClick","handleSlotChange","host","panel","resetTransitionVariables","emit","defaultPrevented","activate","requestAnimationFrame","preventScroll","drawer","once","deactivate","key","propertyName","classList","contains","ref","el","part","class","onKeyDown","onTransitionEnd","onClick","tabIndex","role","name","String","fromCharCode","exportparts","onSlotchange","style","getTextContent","slot","nodes","assignedNodes","flatten","text","map","node","nodeType","Node","TEXT_NODE","textContent","hasSlot","querySelector","Array","from","childNodes","some","trim","ELEMENT_NODE","hasAttribute","fromPairs","acc","k","v","Object","assign","getAvailableSlots","slots","values","reduce","getSlotChildren","_a","assignedElements","getOffset","parent","top","Math","round","getBoundingClientRect","left","locks","Set","lockBodyScrolling","lockingEl","add","body","unlockBodyScrolling","delete","size","remove","scrollIntoView","container","direction","behavior","offset","offsetTop","scrollTop","offsetLeft","scrollLeft","minX","maxX","offsetWidth","minY","maxY","offsetHeight","scrollTo","clientWidth","clientHeight"],"mappings":"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","file":"js/chunk-22fc4fec.6cad35af.js","sourcesContent":["//\r\n// Determines if the browser supports focus({ preventScroll })\r\n//\r\nconst isPreventScrollSupported = () => {\r\n  let supported = false;\r\n  const element = document.createElement('div');\r\n  element.focus &&\r\n    element.focus({\r\n      get preventScroll() {\r\n        supported = true;\r\n        return false;\r\n      },\r\n    });\r\n  return supported;\r\n};\n\nlet activeModals = [];\r\nclass Modal {\r\n  constructor(element, options) {\r\n    this.element = element;\r\n    this.options = options;\r\n    this.handleFocusIn = this.handleFocusIn.bind(this);\r\n  }\r\n  activate() {\r\n    activeModals.push(this.element);\r\n    document.addEventListener('focusin', this.handleFocusIn);\r\n  }\r\n  deactivate() {\r\n    activeModals = activeModals.filter((modal) => modal !== this.element);\r\n    document.removeEventListener('focusin', this.handleFocusIn);\r\n  }\r\n  isActive() {\r\n    // The \"active\" modal is always the most recent one shown\r\n    return activeModals[activeModals.length - 1] === this.element;\r\n  }\r\n  handleFocusIn(event) {\r\n    const target = event.target;\r\n    const tagName = this.element.tagName.toLowerCase();\r\n    // If focus is lost while the modal is active, run the onFocusOut callback\r\n    if (this.isActive() && target.closest(tagName) !== this.element && typeof this.options.onFocusOut === 'function') {\r\n      this.options.onFocusOut(event);\r\n    }\r\n  }\r\n}\n\nexport { Modal as M, isPreventScrollSupported as i };\n","import { r as registerInstance, c as createEvent, h, g as getElement } from './index-a2605a62.js';\nimport { u as unlockBodyScrolling, l as lockBodyScrolling } from './scroll-99b214c2.js';\nimport { h as hasSlot } from './slot-5253e199.js';\nimport { i as isPreventScrollSupported, M as Modal } from './modal-e5709f6b.js';\n\nconst sixDrawerCss = \":host{position:relative;box-sizing:border-box}:host *,:host *:before,:host *:after{box-sizing:inherit}:host{--size:25rem;display:contents}.drawer{top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden}.drawer:not(.drawer--visible){position:absolute;width:1px;height:1px;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;pointer-events:none;visibility:hidden}.drawer--contained{position:absolute;z-index:initial}.drawer--fixed{position:fixed;z-index:var(--six-z-index-drawer)}.drawer__panel{position:absolute;display:flex;flex-direction:column;z-index:2;max-width:100%;max-height:100%;background-color:var(--six-drawer-background-color);color:var(--six-drawer-color);box-shadow:var(--six-shadow-x-large);transition:var(--six-transition-medium) transform;overflow:auto;pointer-events:all}.drawer__panel:focus{outline:none}.drawer--top .drawer__panel{top:0;right:auto;bottom:auto;left:0;width:100%;height:var(--size);transform:translate(0, -100%)}.drawer--right .drawer__panel{top:0;right:0;bottom:auto;left:auto;width:var(--size);height:100%;transform:translate(100%, 0)}.drawer--bottom .drawer__panel{top:auto;right:auto;bottom:0;left:0;width:100%;height:var(--size);transform:translate(0, 100%)}.drawer--left .drawer__panel{top:0;right:auto;bottom:auto;left:0;width:var(--size);height:100%;transform:translate(-100%, 0)}.drawer--open .drawer__panel{transform:none}.drawer__header{display:flex}.drawer__title{flex:1 1 auto;font-size:var(--six-font-size-large);line-height:var(--six-line-height-dense);padding:var(--six-spacing-large)}.drawer__close{flex:0 0 auto;display:flex;align-items:center;font-size:var(--six-font-size-x-large);padding:0 var(--six-spacing-large)}.drawer__body{flex:1 1 auto;padding:var(--six-spacing-large);overflow:auto;-webkit-overflow-scrolling:touch}.drawer__footer{text-align:right;padding:var(--six-spacing-large)}.drawer__footer ::slotted(six-button:not(:last-of-type)){margin-right:var(--six-spacing-x-small)}.drawer:not(.drawer--has-footer) .drawer__footer{display:none}.drawer__overlay{display:block;position:fixed;top:0;right:0;bottom:0;left:0;background-color:var(--six-overlay-background-color);opacity:0;transition:var(--six-transition-medium) opacity;pointer-events:all}.drawer--contained .drawer__overlay{position:absolute}.drawer--open .drawer__overlay{opacity:0.4}\";\n\nconst hasPreventScroll = isPreventScrollSupported();\r\nlet id = 0;\r\nlet SixDrawer = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    this.sixShow = createEvent(this, \"six-drawer-show\", 7);\r\n    this.sixAfterShow = createEvent(this, \"six-drawer-after-show\", 7);\r\n    this.sixHide = createEvent(this, \"six-drawer-hide\", 7);\r\n    this.sixAfterHide = createEvent(this, \"six-drawer-after-hide\", 7);\r\n    this.sixInitialFocus = createEvent(this, \"six-drawer-initial-focus\", 7);\r\n    this.sixOverlayDismiss = createEvent(this, \"six-drawer-overlay-dismiss\", 7);\r\n    this.componentId = `drawer-${++id}`;\r\n    this.willShow = false;\r\n    this.willHide = false;\r\n    this.hasFooter = false;\r\n    this.isVisible = false;\r\n    /** Indicates whether or not the drawer is open. You can use this in lieu of the show/hide methods. */\r\n    this.open = false;\r\n    /**\r\n     * The drawer's label as displayed in the header. You should always include a relevant label even when using\r\n     * `no-header`, as it is required for proper accessibility.\r\n     */\r\n    this.label = '';\r\n    /** The direction from which the drawer will open. */\r\n    this.placement = 'right';\r\n    /**\r\n     * By default, the drawer slides out of its containing block (usually the viewport). To make the drawer slide out of\r\n     * its parent element, set this prop and add `position: relative` to the parent.\r\n     */\r\n    this.contained = false;\r\n    /**\r\n     * Removes the header. This will also remove the default close button, so please ensure you provide an easy,\r\n     * accessible way for users to dismiss the drawer.\r\n     */\r\n    this.noHeader = false;\r\n  }\r\n  handleOpenChange() {\r\n    this.open ? this.show() : this.hide();\r\n  }\r\n  connectedCallback() {\r\n    this.handleCloseClick = this.handleCloseClick.bind(this);\r\n    this.handleTransitionEnd = this.handleTransitionEnd.bind(this);\r\n    this.handleKeyDown = this.handleKeyDown.bind(this);\r\n    this.handleOverlayClick = this.handleOverlayClick.bind(this);\r\n    this.handleSlotChange = this.handleSlotChange.bind(this);\r\n    this.modal = new Modal(this.host, {\r\n      onFocusOut: () => (this.contained ? null : this.panel.focus()),\r\n    });\r\n  }\r\n  componentWillLoad() {\r\n    this.handleSlotChange();\r\n    // Show on init if open\r\n    if (this.open) {\r\n      this.show();\r\n      // if the sidebar is open by default we need to manually reset the\r\n      // transition variables since there will be no transition event\r\n      this.resetTransitionVariables();\r\n    }\r\n  }\r\n  disconnectedCallback() {\r\n    unlockBodyScrolling(this.host);\r\n  }\r\n  /** Shows the drawer */\r\n  async show() {\r\n    if (this.willShow) {\r\n      return;\r\n    }\r\n    const sixShow = this.sixShow.emit();\r\n    if (sixShow.defaultPrevented) {\r\n      this.open = false;\r\n      return;\r\n    }\r\n    this.willShow = true;\r\n    this.isVisible = true;\r\n    this.open = true;\r\n    // Lock body scrolling only if the drawer isn't contained\r\n    if (!this.contained) {\r\n      this.modal.activate();\r\n      lockBodyScrolling(this.host);\r\n    }\r\n    if (this.open) {\r\n      if (hasPreventScroll) {\r\n        // Wait for the next frame before setting initial focus so the dialog is technically visible\r\n        requestAnimationFrame(() => {\r\n          const sixInitialFocus = this.sixInitialFocus.emit();\r\n          if (!sixInitialFocus.defaultPrevented) {\r\n            this.panel.focus({ preventScroll: true });\r\n          }\r\n        });\r\n      }\r\n      else {\r\n        // Once Safari supports { preventScroll: true } we can remove this nasty little hack, but until then we need to\r\n        // wait for the transition to complete before setting focus, otherwise the panel may render in a buggy way its\r\n        // out of view initially.\r\n        //\r\n        // Fiddle: https://jsfiddle.net/g6buoafq/1/\r\n        // Safari: https://bugs.webkit.org/show_bug.cgi?id=178583\r\n        //\r\n        this.drawer.addEventListener('transitionend', () => {\r\n          const sixInitialFocus = this.sixInitialFocus.emit();\r\n          if (!sixInitialFocus.defaultPrevented) {\r\n            this.panel.focus();\r\n          }\r\n        }, { once: true });\r\n      }\r\n    }\r\n  }\r\n  /** Hides the drawer */\r\n  async hide() {\r\n    if (this.willHide) {\r\n      return;\r\n    }\r\n    const sixHide = this.sixHide.emit();\r\n    if (sixHide.defaultPrevented) {\r\n      this.open = true;\r\n      return;\r\n    }\r\n    this.willHide = true;\r\n    this.open = false;\r\n    this.modal.deactivate();\r\n    unlockBodyScrolling(this.host);\r\n  }\r\n  handleCloseClick() {\r\n    this.hide();\r\n  }\r\n  handleKeyDown(event) {\r\n    if (event.key === 'Escape') {\r\n      this.hide();\r\n    }\r\n  }\r\n  handleOverlayClick() {\r\n    const sixOverlayDismiss = this.sixOverlayDismiss.emit();\r\n    if (!sixOverlayDismiss.defaultPrevented) {\r\n      this.hide();\r\n    }\r\n  }\r\n  handleSlotChange() {\r\n    this.hasFooter = hasSlot(this.host, 'footer');\r\n  }\r\n  handleTransitionEnd(event) {\r\n    const target = event.target;\r\n    // Ensure we only emit one event when the target element is no longer visible\r\n    if (event.propertyName === 'transform' && target.classList.contains('drawer__panel')) {\r\n      this.resetTransitionVariables();\r\n    }\r\n  }\r\n  resetTransitionVariables() {\r\n    this.isVisible = this.open;\r\n    this.willShow = false;\r\n    this.willHide = false;\r\n    this.open ? this.sixAfterShow.emit() : this.sixAfterHide.emit();\r\n  }\r\n  render() {\r\n    return (h(\"div\", { ref: (el) => (this.drawer = el), part: \"base\", class: {\r\n        drawer: true,\r\n        'drawer--open': this.open,\r\n        'drawer--visible': this.isVisible,\r\n        'drawer--top': this.placement === 'top',\r\n        'drawer--right': this.placement === 'right',\r\n        'drawer--bottom': this.placement === 'bottom',\r\n        'drawer--left': this.placement === 'left',\r\n        'drawer--contained': this.contained,\r\n        'drawer--fixed': !this.contained,\r\n        'drawer--has-footer': this.hasFooter,\r\n      }, onKeyDown: this.handleKeyDown, onTransitionEnd: this.handleTransitionEnd }, h(\"div\", { part: \"overlay\", class: \"drawer__overlay\", onClick: this.handleOverlayClick, tabIndex: -1 }), h(\"div\", { ref: (el) => (this.panel = el), part: \"panel\", class: \"drawer__panel\", role: \"dialog\", \"aria-modal\": \"true\", \"aria-hidden\": this.open ? 'false' : 'true', \"aria-label\": this.noHeader ? this.label : null, \"aria-labelledby\": !this.noHeader ? `${this.componentId}-title` : null, tabIndex: 0 }, !this.noHeader && (h(\"header\", { part: \"header\", class: \"drawer__header\" }, h(\"span\", { part: \"title\", class: \"drawer__title\", id: `${this.componentId}-title` }, h(\"slot\", { name: \"label\" }, this.label || String.fromCharCode(65279))), h(\"six-icon-button\", { exportparts: \"base:close-button\", class: \"drawer__close\", name: \"x\", onClick: this.handleCloseClick }))), h(\"div\", { part: \"body\", class: \"drawer__body\" }, h(\"slot\", null)), h(\"footer\", { part: \"footer\", class: \"drawer__footer\" }, h(\"slot\", { name: \"footer\", onSlotchange: this.handleSlotChange })))));\r\n  }\r\n  get host() { return getElement(this); }\r\n  static get watchers() { return {\r\n    \"open\": [\"handleOpenChange\"]\r\n  }; }\r\n};\r\nSixDrawer.style = sixDrawerCss;\n\nexport { SixDrawer as six_drawer };\n","//\r\n//\r\n// Given a slot, this function iterates over all of its assigned text nodes and returns the concatenated text as a\r\n// string. This is useful because we can't use slot.textContent as an alternative.\r\n//\r\nfunction getTextContent(slot) {\r\n  const nodes = slot ? slot.assignedNodes({ flatten: true }) : [];\r\n  let text = '';\r\n  [...nodes].map((node) => {\r\n    if (node.nodeType === Node.TEXT_NODE) {\r\n      text += node.textContent;\r\n    }\r\n  });\r\n  return text;\r\n}\r\n//\r\n// Determines whether an element has a slot. If name is specified, the function will look for a corresponding named\r\n// slot, otherwise it will look for a \"default\" slot (e.g. a non-empty text node or an element with no slot attribute).\r\n//\r\nfunction hasSlot(el, name) {\r\n  // Look for a named slot\r\n  if (name) {\r\n    return el.querySelector(`[slot=\"${name}\"]`) !== null;\r\n  }\r\n  // Look for a default slot\r\n  return Array.from(el.childNodes).some((node) => {\r\n    if (node.nodeType === node.TEXT_NODE && node.textContent.trim() !== '') {\r\n      return true;\r\n    }\r\n    if (node.nodeType === node.ELEMENT_NODE) {\r\n      const el = node;\r\n      if (!el.hasAttribute('slot')) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  });\r\n}\r\nconst fromPairs = (acc, [k, v]) => (Object.assign(Object.assign({}, acc), { [k]: v }));\r\nconst getAvailableSlots = (slots) => (host) => Object.values(slots)\r\n  .map((name) => [name, hasSlot(host, name)])\r\n  .reduce(fromPairs, {});\r\nconst getSlotChildren = (el) => { var _a; return (_a = el.querySelector('slot')) === null || _a === void 0 ? void 0 : _a.assignedElements({ flatten: true }); };\n\nexport { getTextContent as a, getSlotChildren as b, getAvailableSlots as g, hasSlot as h };\n","//\r\n// Returns an element's offset relative to its parent. Similar to element.offsetTop and element.offsetLeft, except the\r\n// parent doesn't have to be positioned relative or absolute.\r\n//\r\n// NOTE: This was created to work around what appears to be a bug in Chrome where a slotted element's offsetParent\r\n// seems to ignore elements inside the surrounding shadow DOM: https://bugs.chromium.org/p/chromium/issues/detail?id=920069\r\n//\r\nfunction getOffset(element, parent) {\r\n  return {\r\n    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),\r\n    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left),\r\n  };\r\n}\n\nconst locks = new Set();\r\n//\r\n// Prevents body scrolling. Keeps track of which elements requested a lock so multiple levels of locking are possible\r\n// without premature unlocking.\r\n//\r\nfunction lockBodyScrolling(lockingEl) {\r\n  locks.add(lockingEl);\r\n  document.body.classList.add('six-scroll-lock');\r\n}\r\n//\r\n// Unlocks body scrolling. Scrolling will only be unlocked once all elements that requested a lock call this method.\r\n//\r\nfunction unlockBodyScrolling(lockingEl) {\r\n  locks.delete(lockingEl);\r\n  if (locks.size === 0) {\r\n    document.body.classList.remove('six-scroll-lock');\r\n  }\r\n}\r\n//\r\n// Scrolls an element into view of its container. If the element is already in view, nothing will happen.\r\n//\r\nfunction scrollIntoView(element, container, direction = 'vertical', behavior = 'smooth') {\r\n  const offset = getOffset(element, container);\r\n  const offsetTop = offset.top + container.scrollTop;\r\n  const offsetLeft = offset.left + container.scrollLeft;\r\n  const minX = container.scrollLeft;\r\n  const maxX = container.scrollLeft + container.offsetWidth;\r\n  const minY = container.scrollTop;\r\n  const maxY = container.scrollTop + container.offsetHeight;\r\n  if (direction === 'horizontal' || direction === 'both') {\r\n    if (offsetLeft < minX) {\r\n      container.scrollTo({ left: offsetLeft, behavior });\r\n    }\r\n    else if (offsetLeft + element.clientWidth > maxX) {\r\n      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });\r\n    }\r\n  }\r\n  if (direction === 'vertical' || direction === 'both') {\r\n    if (offsetTop < minY) {\r\n      container.scrollTo({ top: offsetTop, behavior });\r\n    }\r\n    else if (offsetTop + element.clientHeight > maxY) {\r\n      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });\r\n    }\r\n  }\r\n}\n\nexport { getOffset as g, lockBodyScrolling as l, scrollIntoView as s, unlockBodyScrolling as u };\n"],"sourceRoot":""}