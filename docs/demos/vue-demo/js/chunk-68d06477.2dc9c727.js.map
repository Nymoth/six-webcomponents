{"version":3,"sources":["webpack:///./node_modules/@six/ui-library/dist/esm/scroll-99b214c2.js","webpack:///./node_modules/@six/ui-library/dist/esm/six-sidebar.entry.js"],"names":["getOffset","element","parent","top","Math","round","getBoundingClientRect","left","locks","Set","lockBodyScrolling","lockingEl","add","document","body","classList","unlockBodyScrolling","delete","size","remove","scrollIntoView","container","direction","behavior","offset","offsetTop","scrollTop","offsetLeft","scrollLeft","minX","maxX","offsetWidth","minY","maxY","offsetHeight","scrollTo","clientWidth","clientHeight","sixSidebarCss","isSidebarItemGroup","node","tagName","toLowerCase","SixSidebar","hostRef","this","sixShow","sixAfterShow","sixHide","sixAfterHide","sixInitialFocus","willShow","willHide","isVisible","position","open","width","toggled","handleTransitionEnd","event","target","type","contains","resetTransitionVariables","closeSiblingDetailsOnShow","clickedMenuItem","sidebar","closeAllSiblingsBySiblingProperty","getSibling","shadowRoot","querySelector","previousElementSibling","nextElementSibling","show","hide","setupTogglableMenuItems","removeEventListener","markAllMenuItemsAsSelectableEmpty","addEventListener","slot","nodes","assignedElements","menuItems","length","pop","menuItemsForCurrentNode","querySelectorAll","push","newItemGroups","Array","from","children","filter","forEach","details","selectableEmpty","emit","defaultPrevented","index","menuItemsOnRootLevel","map","el","console","error","value","sidebarItemGroups","indexOfSelectedElement","findIndex","name","selectedItem","class","sidebar__container","style","ref","onTransitionEnd"],"mappings":"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","file":"js/chunk-68d06477.2dc9c727.js","sourcesContent":["//\r\n// Returns an element's offset relative to its parent. Similar to element.offsetTop and element.offsetLeft, except the\r\n// parent doesn't have to be positioned relative or absolute.\r\n//\r\n// NOTE: This was created to work around what appears to be a bug in Chrome where a slotted element's offsetParent\r\n// seems to ignore elements inside the surrounding shadow DOM: https://bugs.chromium.org/p/chromium/issues/detail?id=920069\r\n//\r\nfunction getOffset(element, parent) {\r\n  return {\r\n    top: Math.round(element.getBoundingClientRect().top - parent.getBoundingClientRect().top),\r\n    left: Math.round(element.getBoundingClientRect().left - parent.getBoundingClientRect().left),\r\n  };\r\n}\n\nconst locks = new Set();\r\n//\r\n// Prevents body scrolling. Keeps track of which elements requested a lock so multiple levels of locking are possible\r\n// without premature unlocking.\r\n//\r\nfunction lockBodyScrolling(lockingEl) {\r\n  locks.add(lockingEl);\r\n  document.body.classList.add('six-scroll-lock');\r\n}\r\n//\r\n// Unlocks body scrolling. Scrolling will only be unlocked once all elements that requested a lock call this method.\r\n//\r\nfunction unlockBodyScrolling(lockingEl) {\r\n  locks.delete(lockingEl);\r\n  if (locks.size === 0) {\r\n    document.body.classList.remove('six-scroll-lock');\r\n  }\r\n}\r\n//\r\n// Scrolls an element into view of its container. If the element is already in view, nothing will happen.\r\n//\r\nfunction scrollIntoView(element, container, direction = 'vertical', behavior = 'smooth') {\r\n  const offset = getOffset(element, container);\r\n  const offsetTop = offset.top + container.scrollTop;\r\n  const offsetLeft = offset.left + container.scrollLeft;\r\n  const minX = container.scrollLeft;\r\n  const maxX = container.scrollLeft + container.offsetWidth;\r\n  const minY = container.scrollTop;\r\n  const maxY = container.scrollTop + container.offsetHeight;\r\n  if (direction === 'horizontal' || direction === 'both') {\r\n    if (offsetLeft < minX) {\r\n      container.scrollTo({ left: offsetLeft, behavior });\r\n    }\r\n    else if (offsetLeft + element.clientWidth > maxX) {\r\n      container.scrollTo({ left: offsetLeft - container.offsetWidth + element.clientWidth, behavior });\r\n    }\r\n  }\r\n  if (direction === 'vertical' || direction === 'both') {\r\n    if (offsetTop < minY) {\r\n      container.scrollTo({ top: offsetTop, behavior });\r\n    }\r\n    else if (offsetTop + element.clientHeight > maxY) {\r\n      container.scrollTo({ top: offsetTop - container.offsetHeight + element.clientHeight, behavior });\r\n    }\r\n  }\r\n}\n\nexport { getOffset as g, lockBodyScrolling as l, scrollIntoView as s, unlockBodyScrolling as u };\n","import { r as registerInstance, c as createEvent, h } from './index-a2605a62.js';\nimport { s as scrollIntoView } from './scroll-99b214c2.js';\n\nconst sixSidebarCss = \":host{position:relative;box-sizing:border-box}:host *,:host *:before,:host *:after{box-sizing:inherit}:host{display:block;height:100%}.sidebar__container{height:100%;overflow:auto}.sidebar__container.sidebar--open{box-shadow:var(--six-elevation-1dp)}.sidebar__container:not(.sidebar--visible){position:absolute;width:1px;height:1px;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;pointer-events:none;visibility:hidden}.sidebar--left{color:var(--six-sidebar-color);background-color:var(--six-sidebar-background-color);transition:var(--six-transition-medium) margin-left;background-size:300vw 70%;background-position:bottom;background-repeat:no-repeat}.sidebar--right{transition:var(--six-transition-medium) margin-right}.sidebar--open.sidebar--left{margin-right:2px}.sidebar--open.sidebar--right{margin-left:2px}\";\n\nconst isSidebarItemGroup = (node) => node.tagName.toLowerCase() === 'six-sidebar-item-group';\r\nlet SixSidebar = class {\r\n  constructor(hostRef) {\r\n    registerInstance(this, hostRef);\r\n    this.sixShow = createEvent(this, \"six-sidebar-show\", 7);\r\n    this.sixAfterShow = createEvent(this, \"six-sidebar-after-show\", 7);\r\n    this.sixHide = createEvent(this, \"six-sidebar-hide\", 7);\r\n    this.sixAfterHide = createEvent(this, \"six-sidebar-after-hide\", 7);\r\n    this.sixInitialFocus = createEvent(this, \"six-sidebar-initial-focus\", 7);\r\n    this.willShow = false;\r\n    this.willHide = false;\r\n    this.isVisible = false;\r\n    /** Sidebar position */\r\n    this.position = 'left';\r\n    /** Indicates whether or not the sidebar is open. You can use this in lieu of the show/hide methods. */\r\n    this.open = false;\r\n    /** Sidebar width */\r\n    this.width = '16rem';\r\n    /** Define whether sidebar is toggled meaning only one menu can be open at the same time*/\r\n    this.toggled = false;\r\n    this.handleTransitionEnd = (event) => {\r\n      const target = event.target;\r\n      // Ensure we only emit one event when the target element is no longer visible\r\n      if (event.type === 'transitionend' && target.classList.contains('sidebar__container')) {\r\n        this.resetTransitionVariables();\r\n      }\r\n    };\r\n    this.closeSiblingDetailsOnShow = (event) => {\r\n      const clickedMenuItem = event.target;\r\n      scrollIntoView(clickedMenuItem, this.sidebar);\r\n      const closeAllSiblingsBySiblingProperty = (getSibling) => {\r\n        let node = clickedMenuItem;\r\n        while (getSibling(node) !== null) {\r\n          node = getSibling(node);\r\n          if (isSidebarItemGroup(node)) {\r\n            node.shadowRoot.querySelector('six-details').open = false;\r\n          }\r\n        }\r\n      };\r\n      // close all previous siblings\r\n      closeAllSiblingsBySiblingProperty((node) => node.previousElementSibling);\r\n      // close all further siblings\r\n      closeAllSiblingsBySiblingProperty((node) => node.nextElementSibling);\r\n    };\r\n  }\r\n  handleOpenChange() {\r\n    this.open ? this.show() : this.hide();\r\n  }\r\n  componentWillLoad() {\r\n    // Show on init if open\r\n    if (this.open) {\r\n      void this.show();\r\n      // if the sidebar is open by default we need to manually reset the\r\n      // transition variables since there will be no transition event\r\n      this.resetTransitionVariables();\r\n    }\r\n  }\r\n  componentDidRender() {\r\n    this.setupTogglableMenuItems();\r\n  }\r\n  disconnectedCallback() {\r\n    this.sidebar.removeEventListener('six-details-show', this.closeSiblingDetailsOnShow);\r\n  }\r\n  setupTogglableMenuItems() {\r\n    if (!this.toggled) {\r\n      return;\r\n    }\r\n    this.markAllMenuItemsAsSelectableEmpty();\r\n    this.sidebar.addEventListener('six-details-show', this.closeSiblingDetailsOnShow);\r\n  }\r\n  markAllMenuItemsAsSelectableEmpty() {\r\n    // when you have a toggled menu you also want to close other menu items when you click on an item without children\r\n    // nice benefit this item will then also be highlighted\r\n    const slot = this.sidebar.querySelector('slot');\r\n    const nodes = slot.assignedElements();\r\n    // since we don't just want to make the top level empty menuItems selectable in toggled mode,\r\n    // but also nested items we need to traverse the whole menu item tree\r\n    const menuItems = [];\r\n    while (nodes.length > 0) {\r\n      const node = nodes.pop();\r\n      // collect six-details in the current shadowDOM\r\n      const menuItemsForCurrentNode = node.shadowRoot.querySelectorAll('six-details');\r\n      menuItems.push(...menuItemsForCurrentNode);\r\n      // collect all six-sidebar-item-group children of the current node to afterwards check their shadowDOM too\r\n      const newItemGroups = Array.from(node.children).filter(isSidebarItemGroup);\r\n      nodes.push(...newItemGroups);\r\n    }\r\n    menuItems.forEach((details) => (details.selectableEmpty = true));\r\n  }\r\n  /** Toggles whether the sidebar should be shown or hidden */\r\n  async toggle() {\r\n    if (this.willShow || this.willHide) {\r\n      return;\r\n    }\r\n    if (this.open) {\r\n      await this.hide();\r\n    }\r\n    else {\r\n      await this.show();\r\n    }\r\n  }\r\n  /** Shows the sidebar */\r\n  async show() {\r\n    if (this.willShow) {\r\n      return;\r\n    }\r\n    const sixShow = this.sixShow.emit();\r\n    if (sixShow.defaultPrevented) {\r\n      this.open = false;\r\n      return;\r\n    }\r\n    this.willShow = true;\r\n    this.isVisible = true;\r\n    this.open = true;\r\n  }\r\n  /** Hides the sidebar */\r\n  async hide() {\r\n    if (this.willHide) {\r\n      return;\r\n    }\r\n    const sixHide = this.sixHide.emit();\r\n    if (sixHide.defaultPrevented) {\r\n      this.open = true;\r\n      return;\r\n    }\r\n    this.willHide = true;\r\n    this.open = false;\r\n  }\r\n  /** Allows to select a menu item programmatically by index */\r\n  async selectItemByIndex(index) {\r\n    const slot = this.sidebar.querySelector('slot');\r\n    const menuItemsOnRootLevel = slot\r\n      .assignedElements()\r\n      .map((el) => el.shadowRoot.querySelector('six-details'));\r\n    if (index < 0 || index > menuItemsOnRootLevel.length - 1) {\r\n      console.error(`Tried to access sidebar menu item by index, but provided index out of range. Provided index: ${index}`);\r\n      return;\r\n    }\r\n    await menuItemsOnRootLevel[index].show();\r\n  }\r\n  /** Allows to select a menu item programmatically by name */\r\n  async selectItemByName(value) {\r\n    const slot = this.sidebar.querySelector('slot');\r\n    const sidebarItemGroups = slot.assignedElements();\r\n    const indexOfSelectedElement = sidebarItemGroups.findIndex((el) => (el === null || el === void 0 ? void 0 : el.name) === value);\r\n    const selectedItem = sidebarItemGroups[indexOfSelectedElement].shadowRoot.querySelector('six-details');\r\n    await selectedItem.show();\r\n  }\r\n  resetTransitionVariables() {\r\n    this.isVisible = this.open;\r\n    this.willShow = false;\r\n    this.willHide = false;\r\n    this.open ? this.sixAfterShow.emit() : this.sixAfterHide.emit();\r\n  }\r\n  render() {\r\n    return (h(\"host\", { class: \"six-sidebar\" }, h(\"div\", { class: {\r\n        sidebar__container: true,\r\n        'sidebar--visible': this.isVisible,\r\n        'sidebar--open': this.open,\r\n        'sidebar--left': this.position === 'left',\r\n        'sidebar--right': this.position === 'right',\r\n      }, style: {\r\n        width: this.width,\r\n        [`margin-${this.position}`]: this.open ? '0' : `calc(1rem - ${this.width})`,\r\n      }, ref: (el) => (this.sidebar = el), \"aria-hidden\": this.open ? 'false' : 'true', onTransitionEnd: this.handleTransitionEnd }, h(\"slot\", null))));\r\n  }\r\n  static get watchers() { return {\r\n    \"open\": [\"handleOpenChange\"]\r\n  }; }\r\n};\r\nSixSidebar.style = sixSidebarCss;\n\nexport { SixSidebar as six_sidebar };\n"],"sourceRoot":""}